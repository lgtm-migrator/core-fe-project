{"version":3,"file":"json-util.js","sourceRoot":"","sources":["../../src/util/json-util.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AACH,MAAM,UAAU,iBAAiB,CAAC,cAAwB,EAAE,YAAoB;IAAE,cAAc;SAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;QAAd,6BAAc;;IAC5F,IAAM,IAAI,GAAG,IAAI,OAAO,EAAE,CAAC;IAC3B,IAAM,QAAQ,GAAG,UAAC,GAAW,EAAE,KAAU;QACrC,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,EAAE;YAC7C,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;gBACjB,OAAO,SAAS,CAAC;aACpB;YACD,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;SACnB;QAED,IAAI,OAAO,KAAK,KAAK,UAAU,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;YAC1D,OAAO,SAAS,CAAC;SACpB;QACD,IAAI,cAAc,CAAC,IAAI,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAX,CAAW,CAAC,EAAE;YACzC,OAAO,YAAY,CAAC;SACvB;QACD,OAAO,KAAK,CAAC;IACjB,CAAC,CAAC;IAEF,IAAM,OAAO,GAAG,UAAC,CAAM,IAAK,OAAA,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,aAAa,CAAC,EAAzC,CAAyC,CAAC;IACtE,IAAM,gBAAgB,GAAG,IAAI,CAAC,MAAM,CAAC,UAAC,CAAC,IAAK,OAAA,OAAO,CAAC,KAAK,UAAU,IAAI,OAAO,CAAC,KAAK,QAAQ,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,EAA/D,CAA+D,CAAC,CAAC;IAC7G,QAAQ,gBAAgB,CAAC,MAAM,EAAE;QAC7B,KAAK,CAAC;YACF,OAAO,SAAS,CAAC;QACrB,KAAK,CAAC;YACF,OAAO,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;QACzD;YACI,OAAO,IAAI,CAAC,SAAS,CAAC,gBAAgB,EAAE,QAAQ,CAAC,CAAC;KACzD;AACL,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,aAAa,CAAC,IAAY;IACtC,IAAM,eAAe,GAAG,8EAA8E,CAAC;IACvG,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,UAAC,GAAQ,EAAE,KAAU;QACzC,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;YAC1D,OAAO,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC;SAC1B;QACD,OAAO,KAAK,CAAC;IACjB,CAAC,CAAC,CAAC;AACP,CAAC","sourcesContent":["/**\n * Data whose key matches any of the @maskedKeywords RegExp, will be serialized as mask.\n * Useful to serialize sensitive data, e.g. password.\n * Function & Symbol are also discarded in the serialization.\n */\nexport function stringifyWithMask(maskedKeywords: RegExp[], maskedOutput: string, ...args: any[]): string | undefined {\n    const seen = new WeakSet();\n    const replacer = (key: string, value: any) => {\n        if (typeof value === \"object\" && value !== null) {\n            if (seen.has(value)) {\n                return undefined;\n            }\n            seen.add(value);\n        }\n\n        if (typeof value === \"function\" || typeof value === \"symbol\") {\n            return undefined;\n        }\n        if (maskedKeywords.some((_) => _.test(key))) {\n            return maskedOutput;\n        }\n        return value;\n    };\n\n    const isEvent = (e: any) => Boolean(e && e.target && e.currentTarget);\n    const serializableArgs = args.filter((_) => typeof _ !== \"function\" && typeof _ !== \"symbol\" && !isEvent(_));\n    switch (serializableArgs.length) {\n        case 0:\n            return undefined;\n        case 1:\n            return JSON.stringify(serializableArgs[0], replacer);\n        default:\n            return JSON.stringify(serializableArgs, replacer);\n    }\n}\n\n/**\n * If an ISO format date (2018-05-24T12:00:00.123Z) appears in the JSON, it will be transformed to JS Date type.\n */\nexport function parseWithDate(data: string) {\n    const ISO_DATE_FORMAT = /^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d(\\.\\d+)?(Z|[+-][01]\\d:[0-5]\\d)$/;\n    return JSON.parse(data, (key: any, value: any) => {\n        if (typeof value === \"string\" && ISO_DATE_FORMAT.test(value)) {\n            return new Date(value);\n        }\n        return value;\n    });\n}\n"]}