{"version":3,"file":"hooks.js","sourceRoot":"","sources":["../src/hooks.ts"],"names":[],"mappings":";AAAA,OAAO,KAAK,MAAM,OAAO,CAAC;AAE1B,OAAO,EAAC,WAAW,EAAE,WAAW,EAAC,MAAM,aAAa,CAAC;AAIrD,MAAM,UAAU,gBAAgB,CAAC,UAA6B;IAA7B,2BAAA,EAAA,qBAA6B;IAC1D,OAAO,WAAW,CAAC,UAAC,KAAY,IAAK,OAAA,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,EAA7B,CAA6B,CAAC,CAAC;AACxE,CAAC;AAOD;;;GAGG;AACH,MAAM,UAAU,SAAS,CAAgE,aAAwC;IAAE,cAAU;SAAV,UAAU,EAAV,qBAAU,EAAV,IAAU;QAAV,6BAAU;;IACzI,IAAM,QAAQ,GAAG,WAAW,EAAE,CAAC;IAC/B,OAAO,KAAK,CAAC,WAAW,CAAC,cAAM,OAAA,QAAQ,CAAC,aAAa,wCAAI,IAAI,WAAE,EAAhC,CAAgC,EAAE,IAAI,CAAC,CAAC;AAC3E,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,cAAc,CAAqB,aAAgF;IAAE,cAAU;SAAV,UAAU,EAAV,qBAAU,EAAV,IAAU;QAAV,6BAAU;;IAC3I,IAAM,QAAQ,GAAG,WAAW,EAAE,CAAC;IAC/B,OAAO,KAAK,CAAC,WAAW,CAAC,UAAC,GAAM,IAAK,OAAA,QAAQ,CAAC,aAAa,sDAAI,IAAI,YAAE,GAAG,WAAE,EAArC,CAAqC,EAAE,IAAI,CAAC,CAAC;AACtF,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,eAAe,CAAwB,aAAsF;IAAE,cAAU;SAAV,UAAU,EAAV,qBAAU,EAAV,IAAU;QAAV,6BAAU;;IACrJ,IAAM,QAAQ,GAAG,WAAW,EAAE,CAAC;IAC/B,OAAO,KAAK,CAAC,WAAW,CAAC,UAAC,IAAO,EAAE,IAAO,IAAK,OAAA,QAAQ,CAAC,aAAa,sDAAI,IAAI,YAAE,IAAI,EAAE,IAAI,WAAE,EAA5C,CAA4C,EAAE,IAAI,CAAC,CAAC;AACvG,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,kBAAkB,CAAsC,aAAsC,EAAE,SAAY;IACxH,IAAM,QAAQ,GAAG,WAAW,EAAE,CAAC;IAC/B,OAAO,KAAK,CAAC,WAAW,CAAC,UAAC,WAAiB;;QAAK,OAAA,QAAQ,CAAC,aAAa,CAAC,CAAA,SAAC,GAAC,SAAS,IAAG,WAAW,IAAM,CAAA,CAAC,CAAC;IAAxD,CAAwD,EAAE,CAAC,QAAQ,EAAE,aAAa,EAAE,SAAS,CAAC,CAAC,CAAC;AACpJ,CAAC","sourcesContent":["import React from \"react\";\nimport {Action, State} from \"./reducer\";\nimport {useDispatch, useSelector} from \"react-redux\";\n\ntype DeferLiteralArrayCheck<T> = T extends Array<string | number | boolean | null | undefined> ? T : never;\n\nexport function useLoadingStatus(identifier: string = \"global\"): boolean {\n    return useSelector((state: State) => state.loading[identifier] > 0);\n}\n\ninterface IdleStatus {\n    idle: boolean;\n    startAt: number | null;\n}\n\n/**\n * Action parameters must be of primitive types, so that the dependency check can work well.\n * No need add dispatch to dep list, because it is always fixed.\n */\nexport function useAction<P extends Array<string | number | boolean | null | undefined>>(actionCreator: (...args: P) => Action<P>, ...deps: P): () => void {\n    const dispatch = useDispatch();\n    return React.useCallback(() => dispatch(actionCreator(...deps)), deps);\n}\n\n/**\n * For actions like:\n * *foo(a: number, b: string, c: boolean): SagaGenerator {..}\n *\n * useUnaryAction(foo, 100, \"\") will return:\n * (c: boolean) => void;\n */\nexport function useUnaryAction<P extends any[], U>(actionCreator: (...args: [...P, U]) => Action<[...DeferLiteralArrayCheck<P>, U]>, ...deps: P): (arg: U) => void {\n    const dispatch = useDispatch();\n    return React.useCallback((arg: U) => dispatch(actionCreator(...deps, arg)), deps);\n}\n\n/**\n * For actions like:\n * *foo(a: number, b: string, c: boolean): SagaGenerator {..}\n *\n * useBinaryAction(foo, 100) will return:\n * (b: string, c: boolean) => void;\n */\nexport function useBinaryAction<P extends any[], U, K>(actionCreator: (...args: [...P, U, K]) => Action<[...DeferLiteralArrayCheck<P>, U, K]>, ...deps: P): (arg1: U, arg2: K) => void {\n    const dispatch = useDispatch();\n    return React.useCallback((arg1: U, arg2: K) => dispatch(actionCreator(...deps, arg1, arg2)), deps);\n}\n\n/**\n * For actions like:\n * *foo(data: {key: number}): SagaGenerator {..}\n *\n * useModuleObjectAction(foo, \"key\") will return:\n * (objectValue: number) => void;\n */\nexport function useObjectKeyAction<T extends object, K extends keyof T>(actionCreator: (arg: T) => Action<[T]>, objectKey: K): (objectValue: T[K]) => void {\n    const dispatch = useDispatch();\n    return React.useCallback((objectValue: T[K]) => dispatch(actionCreator({[objectKey]: objectValue} as T)), [dispatch, actionCreator, objectKey]);\n}\n"]}